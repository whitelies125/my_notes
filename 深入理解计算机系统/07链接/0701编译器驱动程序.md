# 编译器驱动程序

大多数编译系统提供**编译器驱动程序（compiler driver）**，它代表用户在需要时调用：语言预处理器、编译器、汇编器、链接器。

例如，此处有两个 C 语言源文件：

~~~C++
//main.c
int sum(int* a, int n);

int array[2] = {1, 2};

int main(){
    int val = sum(array,2);
    return val;
}

//sum.c
int sum(int* a, int n){
    int i, s = 0;
    for(i = 0; i < n; i++){
        s += a[i];
    }
    return s;
}
~~~

使用 GNU 编译系统构造该程序，则需通过在 shell 中输入下列命令来调用 GCC 驱动程序。

~~~
gcc -Og -o prog main.c sum.c
~~~

其中，

- -Og

  Optimize debugging experience

  -Og 选项使得优化并不会干扰 debug。
  对于标准的编辑-编译-debug 周期来说，它是标准的优化等级选择，它提供合理的优化等级，同时保持快速的编译和良好的 debug 体验。

  在实际项目中，为了程序的性能，通常采用 -O1 或-O2 的优化选项。

- -o

  output file

  指定输出的可执行文件的文件名。

  此处指定的文件名为 prog，若不指定，则默认输出的可执行文件名为 a.out。

实际过程：

~~~shell
C:\Users\98099\Desktop\test>dir /b
main.c
sum.c

C:\Users\98099\Desktop\test>gcc -Og -o prog main.c sum.c

C:\Users\98099\Desktop\test>dir /b
main.c
prog.exe
sum.c

C:\Users\98099\Desktop\test>
~~~

可见，执行命令后生成了 prog.exe。

<img src="0707_链接生成可执行文件.png" alt="0707_链接生成可执行文件" style="zoom:80%;" />

<center>图1. 链接生成可执行文件</center>

如图一所示，概括了从 ASCII 码源文件翻译成为可执行目标文件时的行为。

下面对该过程进行细分讲解。

## 预处理

驱动程序首先运行 **C 语言预处理器（cpp，c preprocessor）**，它将 C 的源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i。

我们可以使用下列命令来调用 cpp 执行这个操作。

~~~shell
cpp -o main.i main.c
~~~

当然，也可以传入 -E 选项来使用 gcc 完成相同的任务。

~~~shell
gcc -E -o main.i main.c
~~~

其中 -E 选项用于限制 gcc 只进行预处理，而不进行后续编译、汇编、链接的操作。

实际过程：

~~~shell
C:\Users\98099\Desktop\test>dir /b
main.c
sum.c

C:\Users\98099\Desktop\test>cpp -o main.i main.c

C:\Users\98099\Desktop\test>dir /b
main.c
main.i
sum.c

C:\Users\98099\Desktop\test>
~~~

可以以记事本打开 main.i 文件，其内容为：

~~~text
# 0 "main.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "main.c"

int sum(int* a, int n);

int array[2] = {1, 2};

int main(){
    int val = sum(array,2);
    return val;
}
~~~

## 编译

接下来，驱动程序运行 **C 编译器（cc1，c compiler）**，它将 main.i 翻译成一个 ASCII 码汇编语言文件 main.s。

命令：

~~~shell
cc1 -o main.s main.i
~~~

同样可以以 -S 选项来使用 gcc 完成相同的任务。

~~~shell
gcc -S -o main.s main.i
~~~

其中 -S 选项表示只对文件进行编译，而不进行后续汇编、链接的操作。

实际过程：

~~~shell
C:\Users\98099\Desktop\test>dir /b
main.c
main.i
sum.c

C:\Users\98099\Desktop\test>cc1 -o main.s main.i
 main
Analyzing compilation unit
Performing interprocedural optimizations
 <*free_lang_data> <visibility> <build_ssa_passes> <opt_local_passes> <remove_symbols> <targetclone> <free-fnsummary> <emutls>Streaming LTO
 <whole-program> <fnsummary> <inline> <modref> <free-fnsummary> <single-use>Assembling functions:
 <simdclone> main
Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 ( 13%)  1302k ( 86%)
 phase opt and generate             :   0.02 ( 65%)    57k (  4%)
 callgraph optimization             :   0.01 ( 32%)     0  (  0%)
 callgraph ipa passes               :   0.01 ( 26%)  4960  (  0%)
 TOTAL                              :   0.03         1513k

C:\Users\98099\Desktop\test>dir /b
main.c
main.i
main.s
sum.c

C:\Users\98099\Desktop\test>
~~~

同样的，main.s 也是 ASCII 码文件，所以也可用记事本打开查看：

~~~text
	.file	"main.i"
	.text
	.globl	array
	.data
	.align 8
array:
	.long	1
	.long	2
	.def	__main;	.scl	2;	.type	32;	.endef
	.text
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	subq	$48, %rsp
	.seh_stackalloc	48
	.seh_endprologue
	call	__main
	movl	$2, %edx
	leaq	array(%rip), %rax
	movq	%rax, %rcx
	call	sum
	movl	%eax, -4(%rbp)
	movl	-4(%rbp), %eax
	addq	$48, %rsp
	popq	%rbp
	ret
	.seh_endproc
	.ident	"GCC: (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 11.3.0"
	.def	sum;	.scl	2;	.type	32;	.endef

~~~

## 汇编

然后，驱动程序运行**汇编器（as，assembler）**，它将 main.s 翻译成一个**可重定位目标文件（relocatable object file)** main.o。

命令：

~~~shell
as -o main.o main.s
~~~

同样可以以 -S 选项来使用 gcc 完成相同的任务。

~~~shell
gcc -c -o main.o main.s
~~~

其中 -c 选项表示只对文件进行汇编，而不进行后续链接的操作。

实际过程：

~~~shell
C:\Users\98099\Desktop\test>dir /b
main.c
main.i
main.s
sum.c

C:\Users\98099\Desktop\test>as -o main.o main.s

C:\Users\98099\Desktop\test>dir /b
main.c
main.i
main.o
main.s
sum.c

C:\Users\98099\Desktop\test>
~~~

main.o 不再是 ASCII 码文件，而是二进制文件，因此，如果使用记事本查看，只会看到乱码。

同样的，驱动程序经过相同的步骤，生成 sum.o 文件。

我们手动操作的话，实际上，直接使用

~~~shell
gcc -c -o sum.o sum.c
~~~

即可得到 sum.o 文件。

## 链接

最后，驱动程序运行**链接器程序（ld）**，将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个**可执行目标文件（executable object file）** prog.exe。

注：链接器的英文是 linker，但往往缩写为 ld。虽然 ld 实际上是 loader 或 link editor 的缩写。

> 引用自维基百科：
>
> On Unix and Unix-like systems, the linker is known as "ld". Origins of the name "ld" are "LoaDer" and "Link eDitor". The term "loader" was used to describe the process of loading external symbols from other programs during the process of linking.

命令：

~~~shell
ld -o prog main.o sum.o [system object files and args]
~~~

注意，除了 main.o 和 sun.o 以外，还需要链接一些其它的必要的文件。

所以仅仅

~~~shell
ld -o prog main.o sum.o
~~~

是不行的，会报错：

~~~shell
C:\Users\98099\Desktop\test>ld -o prog main.o sum.o
ld: main.o:main.i:(.text+0x9): undefined reference to `__main'

C:\Users\98099\Desktop\test>
~~~

不过，书并没有给出详细命令，这里就不细究了。

这里偷懒，使用

~~~shell
gcc -o prog main.o sum.o
~~~

来进行链接，生成 prog.exe 文件。

实际过程：

~~~shell
C:\Users\98099\Desktop\test>dir /b
main.c
main.i
main.o
main.s
sum.c
sum.o

C:\Users\98099\Desktop\test>gcc -o prog main.o sum.o

C:\Users\98099\Desktop\test>dir /b
main.c
main.i
main.o
main.s
prog.exe
sum.c
sum.o

C:\Users\98099\Desktop\test>
~~~

## 运行

要执行可执行文件 prog，在 shell 中输入其文件名即可。

~~~shell
./prog
~~~

shell 调用操作系统中一个叫作**加载器（loader）**的函数，它将可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。
