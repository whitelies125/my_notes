# 顶层/底层 const

指针与 const 主要就是涉及到到底谁是常量的问题，是指针（地址），还是指针所指的数据。

**顶层 const（top-level const）** 表示指针本身是一个常量。
**底层 const（low-level const）**表示指针所指的对象是一个常量。

来自 <C++ Primer（第 5 版）>

更一般的，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层 const 则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层 const 也可以是底层 const，这一点和其它类型相比区别明显

~~~C++
int i = 0;
int* const p1 = &i;			// 不能改变 p1 的值，这是一个顶层 const
const int ci = 42;			// 不能改变 ci 的值，这是一个顶层 const
const int* p2 = &ci;		// 允许改变 p2 的值，这是一个底层 const
const int* const p3 = p2;	// 靠右的 const 是顶层 const，靠左的是底层 const
const int& r = ci;			// 用于声明引用的 const 都是底层 const
~~~

当执行对象的拷贝操作时，常量是顶层 const 还是底层 const 区别明显。其中，顶层 const 不受什么影响：

~~~C++
i = ci;		// 正确，拷贝 ci 的值，ci 是一个顶层 const，对此操作无影响
p2 = p3;	// 正确，p2 和 p3 指向的对象类型相同，p3 顶层 const 的部分不受影响
~~~

指向拷贝操作并不会改变拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。

另一方面，底层 const 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换为常量，反之不行。

~~~C++
int* p = p3;		// 错误，p3 包含底层 const 的定义，而 p 没有
p2 = p3;			// 正确，p2 和 p3 都是底层 const
p2 = &i;			// 正确，int* 能转换为 const int*
int& r = ci;		// 错误，普通的 int& 不能绑定到 int 常量上
const int& r2 = i;	// 正确，const int& 可以绑定到一个普通 int 上
~~~

p3 既是顶层 const 也是底层 const，拷贝 p3 时可以不在乎它是一个顶层 const，但是必须清楚它指向的对象得是一个常量。因此，不能用 p3 去初始化 p，因为 p 指向的是一个普通的（非常量）整数。另一方面，p3 的值可以赋给 p2，是因为这两个指针都是底层 const，尽管 p3 同时也是一个常量指针（顶层 const），仅就这次赋值而言不会有什么影响。

2022.08.31
