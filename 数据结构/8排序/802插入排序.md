# 插入排序

基本思想，每次将一个待排序的记录按其关键字大小插入到已经排好序的子序列中，直到全部记录插入完成。

如果不加特殊说明，一般默认排序结果为非递减有序序列。

## 一. 直接插入排序

利用了 "哨兵" （A[0]）的插入排序：

~~~c
void InsertSort(ElemType A[],int n){
    int i = 1;
    int j = 1;
    for( i = 2; i <= n; i++){	//从 A[2] 到 A[n] 依次插入到前面已有序的序列中
        A[0] = A[i];	//将 A[i] 的值保存到 A[0]，相当于 A[i] 是可用的了
		for( j = i-1; A[0]<A[j]; j--){//从后向前查找要插入的位置，找到插入单元的前一个单元
            A[j+1] = A[j];	//因为 A[i] 的值已经保持了，所以A[i] 之前的序列可以往后移动一格
        }
        A[j+1] = A[0];	//将事先保存的 A[i]，插入到要插入的单元
    }
}
~~~

算法稳定性：稳定。

空间复杂度：$O(1)$​ 。

时间复杂度：$O(n^2)$​​ 。

最好情况：比较次数：$\sum\limits_{i=2}^{n}1$​​ ，移动次数：$0$​​ ，时间复杂度 $O(n)$ ；
最坏情况：比较次数：$\sum\limits_{i=2}^{n}i$ ，移动次数：$\sum\limits_{i=2}^{n}(i+1)$​​​ ，时间复杂度 $O(n^2)$ 。

取二者平均，则插入排序对比次数约为 $\frac{n^2}{4}$ ，移动次数约为 $\frac{n^2}{4}$ 。

## 二. 折半插入排序

对直接插入排序的一点优化，

直接插入排序中，其实可以分为了两步，第一步是找到插入位置，第二步是进行插入。
不过在插入排序中这两步是混着的。

所以我们分离开，这样在第一步时，如果是线性表，则可以使用折半查找来提高效率。
找到了插入位置后，再在第二步中进行插入，以及插入位置后的元素依次右移。

~~~c
void InsertSort(ElemType A[],int n){
    int i = 1;
    int j = 1;
    int low = 0;
    int mid = 0;
    int high = 0;
    for( i = 2; i <= n; i++){	//从 A[2] 到 A[n] 依次插入到前面已有序的序列中
        A[0] = A[i];	//将 A[i] 的值保存到 A[0]，相当于 A[i] 是可用的了
		low = 1;
        high = i-1;
		while( low <= high){	//折半查找找到要插入的位置的前一个元素
            mid = (low + high) / 2;
            if( A[mid] > A[0] )
                high = mid - 1;
            else
                low = mid + 1;
        }
        for( j = i-1; j >= high + 1; j--){//从后向前，依次把元素右移一位
            A[j+1] = A[j];
        }
        A[high+1] = A[0];	//插入将事先保存的 A[i]
    }
}
~~~

由于使用了折半查找，所以比较次数约为 $O(n\log_2 n)$ 。

时间复杂度仍为 $O(n^2)$ 。

算法稳定性：稳定。

## 三. 希尔排序

又称**最小增量排序**。

由于直接插入排序适合基本有序的排序表。希尔排序就是先将排序表分为若干个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子表，对各子表进行直接插入排序，使得排序表基本有序，才对排序表进行直接插入排序。

~~~c
void ShellSort( Elemtype A[], int n){
    for(dk = n/2; dk >=1; dk = dk/2){ 	//步长变换
        for(i = dk+1; i<=n; i++){	//对某一步长下的所有子表进行插入排序
            if(A[i]<A[i-dk]){
                A[0] = A[i];	//A[0]暂存
                for(j = i-dk; j>0 && A[0]<A[j]; j -= dk)	//查找插入位置
                    A[j+dk] = A[j];	//同时使元素右移
                A[j+dk] = A[0];	//插入
            }
        }
    }
}
~~~

空间复杂度：$O(1)$ ；

时间复杂度：$O(n^2)$ ，当 n 在某个特定范围内时，希尔排序的时间复杂度约为 $O(n^1.3)$ 。

算法稳定性：稳定。

适用性：仅适用于线性表为顺序存储的情况。

2021.08.13

