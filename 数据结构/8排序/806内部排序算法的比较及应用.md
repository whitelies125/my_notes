# 内部排序算法的比较及应用

## 一. 内部排序算法的比较

| 算法种类     | 时间复杂度     |                |                | 空间复杂度    | 稳定性 |
| ------------ | -------------- | -------------- | -------------- | ------------- | ------ |
|              | 最好情况       | 平均情况       | 最坏情况       |               |        |
| 直接插入排序 | $O(n)$         | $O(n^2)$       | $O(n^2)$       | $O(1)$        | 稳定   |
| 冒泡排序     | $O(n)$         | $O(n^2)$       | $O(n^2)$       | $O(1)$        | 稳定   |
| 简单选择排序 | $O(n^2)$       | $O(n^2)$       | $O(n^2)$       | $O(1)$        | 否     |
| 希尔排序     | 依赖于增量函数 | 依赖于增量函数 | 依赖于增量函数 | $O(1)$        | 否     |
| 快速排序     | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n^2)$       | $O(\log_2 n)$ | 否     |
| 堆排序       | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(1)$        | 否     |
| 2 路归并排序 | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n)$        | 稳定   |
| 基数排序     | $O(d*(n+r))$   | $O(d*(n+r))$   | $O(d*(n+r))$​   | $O(r)$        | 稳定   |

希尔排序的时间复杂度依赖于增量函数，故没有给出时间复杂度。

空间复杂度仅给出了平均情况的空间复杂度。

我还是用学的顺序来排列吧：

| 算法种类     | 时间复杂度     |                |                | 空间复杂度    | 稳定性 |
| ------------ | -------------- | -------------- | -------------- | ------------- | ------ |
|              | 最好情况       | 平均情况       | 最坏情况       |               |        |
| 直接插入排序 | $O(n)$         | $O(n^2)$       | $O(n^2)$       | $O(1)$        | 稳定   |
| 希尔排序     | 依赖于增量函数 | 依赖于增量函数 | 依赖于增量函数 | $O(1)$        | 否     |
|              |                |                |                |               |        |
| 冒泡排序     | $O(n)$         | $O(n^2)$       | $O(n^2)$       | $O(1)$        | 稳定   |
| 快速排序     | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n^2)$       | $O(\log_2 n)$ | 否     |
|              |                |                |                |               |        |
| 简单选择排序 | $O(n^2)$       | $O(n^2)$       | $O(n^2)$       | $O(1)$        | 否     |
| 堆排序       | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(1)$        | 否     |
|              |                |                |                |               |        |
| 2 路归并排序 | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n)$        | 稳定   |
| 基数排序     | $O(d*(n+r))$   | $O(d*(n+r))$   | $O(d*(n+r))$​   | $O(r)$        | 稳定   |

## 二. 内部排序算法的应用

通常，对排序算法的比较和应用考虑以下情况：

### 2.1 选取排序算法需要考虑的因素：

选取排序算法需要考虑的因素：

1. 待排序的元素数目 n；
2. 元素本身信息量的大小；
3. 关键字的结构及其分布情况；
4. 稳定性的要求；
5. 语言工具的条件，存储结构及服组空间的大小等。

### 2.2 排序算法小结：

排序算法小结：

1. 若 n 较小，可采用直接拆入排序或简单选择排序。

2. 若文件的初始状态已按关键字基本有序，则选用直接插入排序或冒泡排序为宜。

3. 若 n 较大，则应采用时间复杂度为 $O(n\log_2 n)$ 的排序方法：快速排序、堆排序、归并排序。

4. 快速排序被认为是目前基于比较的内部排序算法中最好的方法，当待排序关键字随机分布时，快速排序的平均时间最短。

   堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。但这两种排序都是不稳定的。

   若要求排序稳定且时间复杂度为 $O(n\log_2 n)$​ ，则可选用归并排序。
   王道说它的从单个记录开始进行的两两归并的排序算法（也就是前面归并排序的算法）并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后两两归并。
   直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。

5. 在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，因此可用一颗二叉树来描述比较判定的过程，由此可以证明：当文件的 n 个关键字随机分布时，任何借助于 "比较" 的排序算法，至少需要 $O(n\log_2 n)$ 的时间。

6. 若 n 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。

7. 当记录本身信息量较大时，为了比较好烦大量时间移动记录，可用链表作为存储结构。

2021.08.14
