# 拓扑排序

AOV 网：若用 DAG 图表示一个工程，其顶点表示活动，用有向边 $<v_i,v_j>$ 表示活动 $v_i$ 必须先于活动 $v_j$ 进行的一种关系，则将这种有向图成位**顶点表示活动的忘了**，记为 **AOV 网**。
在 AOV 网中，活动 $v_i$ 是活动 $v_j$ 的直接前驱，活动 $v_j$ 是活动 $v_i$ 的直接后继，这种前驱后继关系具有传递性，且任何活动 $v_i$​ 不能以它自己作为自己的前驱或后继。

AOV 网是有向无环图。

**拓扑排序**：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为图的一个拓扑排序：

1. 每个顶点出现且只出现一次。
2. 若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径。

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点 A 到顶点 B 的路径，则在排序中顶点 B 出现在顶点 A 的后面。

每个 AOV 网都有一个或多个拓扑排序。
不过，若有向无环图拓扑序列唯一，但并不能唯一确定该有向无环图。

对 AOV 网进行拓扑排序的算法很多，这里只举出一种比较常用的方法的步骤：

1. 从 AOV 网中选择删除一个没有前驱的顶点并输出。
2. 从网中删除该顶点和所有以它为起点的有向边。
3. 重复第 1，2 步直到当前的 AOV 网为空，或当前网中不存在无前驱的顶点为止。后一种情况说明该有向图中必然存在环。

算法实现：

~~~c
bool ToplogicalSort(Graph G){
    IniStack(S);
    for( int i = 0; i < G.vexnum; i++){
        if( indegree[i] == 0 ){	//所有入度为 0 的顶点入栈
            Push(S,i);
        }
    }
    int count = 0;
    while( !IsEmpty(S) ){
        Pop(S,i);	//出栈一个顶点
        print[count] = i;	//输出该顶点
        count ++;
        for( p = G.vertices[i].firstarc; p; p = p->nextrac){
		//将该顶点指向的所有顶点的入度减 1
            v = p->adjvex;
            indegree[v] --;
            if( !indegree[v] ){	//如果入度为 0 了，则入栈
                Push(S,v);
            }
        }
    }
    if(count < G.vexnum)//输出的顶点数，小于，有向图总顶点数
		return false;	//排序失败，有向图中有回路
	else
		return true;	//拓扑排序成功
}
~~~

拓扑排序的时间复杂度 $O(|V|+|E|)$ 。

对一个 AOV 网，如果采用下列步骤进行排序，则称之为**逆拓扑排序**：

1. 从 AOV 网中选择删除一个没有后继的顶点并输出。
2. 从网中删除该顶点和所有以它为终点的有向边。
3. 重复第 1，2 步直到当前的 AOV 网为空。

注意，由于 AOV 网中各顶点的地位平等，每个编号是人为的，因此可以按拓扑排序的结果重新编号，生成 AOV 网的新的邻接存储矩阵。这种邻接矩阵可以是三角矩阵。
但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑排序；反之则不一定。

2021.08.08