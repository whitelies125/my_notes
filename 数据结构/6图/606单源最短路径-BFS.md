# 单源最短路径-BFS

## 一. 最短路径

在前面 604 图的遍历中的 BFS 中已经讲述过一个求最短路径，不过那是对无权无向图，而且也只求出了从初始点到其他点的是否存在路径以及路径距离。

这里讲的是，当图为带权图时，把从一个顶点 $v_0$ 到图中其余任意一个顶点 $v_i$​​ 的一条路径（可能不止一条）所经过的边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径成为**最短路径**。

那么这种情况，BFS 就没办法了，BFS 只能够处理无权图（当然权值都相等的图也行）。

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包括了路径上其他项点间的最短路径。

带权有向图 G 的最短路径问题一般可分为两类：
一类是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可用 Dijstra 算法求解；
二是求每对顶点间的最短路径，可用 Floyd 算法求解。

## 二. 单源最短路径-BFS

不过，我们这里先把 BFS 求单源最短路径给补充完。

~~~c
void BFS_MIN_Distance(Graph G, int u){
    for( i = 0; i < G.vexnum; i++){
        d[i] = ∞;		//记录距离的数组
        path[i] = -1;	//记录路径直接前驱的数组
    }
    d[u] = 0;
    visited[u] = TRUE;	//当然也有记录是否已被访问过的数组
    EnQueue(Q,u);
    while( !IsEmpty(Q) ){
        DeQueue(Q,u);
        for( w = FirstNeighbor(G,u); w >= 0; w  = NextNeighbor(G,u,w) ){
            d[w] = d[u] + 1;
            path[w] = u;
            visited[w] = TRUE;
            EnQueue(w);
        }
    }
}
~~~

还是简单的。

无法就是增加了 path[] 数组记录到该店的最短路径前驱。

本质上，也就是把 BFS 伪代码中的 visit()，换成我们要做的操作。

2021.08.07

