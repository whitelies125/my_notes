# 505 TCP 可靠传输

TCP 实现可靠传输的机制：校验、序号、确认、重传

#### 校验

和 UDP 类似的，通过检验和对 TCP 报文段进行校验，判断是否出错。

#### 序号

把要发送的一段字节，形成一个报文段进行发送，报文段首部的序号字段，即该报文段数据部分第一个字节的字节序号。

#### 确认

接收方收到了报文段（经检验和检验无错，确定接收了），则发出对该报文段的 ACK，其中确认号字段为接收的报文段的数据部分最后一个字节的字节序号加 1，即期待收到的下一个字节的字节序号。

TCP 默认使用累计重传机制，接收了报文段，则发送已接收的报文段中，最前面的连续的报文段中的，序号大的报文段的 ACK；

#### 重传

TCP 在规定的时间内没有收到确认，就要重传已发送的报文段。

由于数据在网络中传送的路径不定， 每次发送数据走的路径都可能不同，所以到达接收端、收到确认的时间时快时慢。也就是每个报文段的往返时间长短不一。

显然，重传时间应该大于报文段的往返时间。
但这样的情况，如果设置一个固定的重传时间，对于经过多个速率慢的网络的报文段，其本身是能够到达接收方的只是慢点，但也会因为超过重传时间所以重传。如果加长固定的重传时间，那么重传时间太长，使得数据的传送变慢。

因此，TCP 使用自适应算法，动态计算出**加权平均往返时间 $RTT_S$ **（又称为**平滑的往返时间**）。
$$
新的RTT_S=(1-\alpha)\times(旧的RTT_S)+\alpha\times(新的RTT样本)
$$
新的 RTT 样本就是每次新发送出去报文段，收到确认的时间。

RFC 6298 推荐的 $\alpha=1/8$ ，即便 0.125。

超时计时器设置的**超时重传时间 RTO（RetransmissionTime-Out）**应该略大于 TCP 动态计算出的 RTTs，RFC 6298 建议：
$$
RTO=RTT_S+4\times RTT_D\tag{1.1}
$$
其中 $RTT_D$ 是 RTT 的偏差的加权平均值，它与 $RTT_S$ 和新的 RTT 样本之差有关。
RFC 6298 建议这样计算 $RTT_D$ ：第一次测量时， $RTT_D$ 值取为测量到的 RTT 样本值的一半；以后的测量中，使用下式：
$$
新的 RTT_D=(1-\beta)\times(旧的RTT_D)+\beta\times|RTT_S-新的RTT样本|
$$
此处 $\beta$ 的推荐值是 $\beta = 1/4$ ，即 0.25。

##### Karn 算法

不过，即便是这样，也存在问题，因为存在情况：发出报文段，超时重传报文段（可能多次重传），然后收到 ACK，此时发送端无法判断，这个 ACK 是对那一次发送出去的报文段的 ACK。
因为这些 ACK 都是一样的。

如果发送方把该 ACK 认为是第 n 次重传报文段的 ACK，但实际该 ACK 是第 m（m>n）次重传报文段的 ACK，就会导致 $RTT_S$ 偏大。
如果发送方把该 ACK 认为是第 m 次重传报文段的 ACK，但实际该 ACK 是第 n（m>n）次重传报文段的 ACK，就会导致 $RTT_S$ 偏小。

所以，Karn 提出了一个算法：在计算 $RTT_S$ 时，只要报文段重传了，就不采用其往返时间样本。
这样，就避免了上述情况。

不过也有了新的问题，当报文段的时延突然增大了许多，根据 Karn 算法，只要重传了就不考虑该重传报文段的样本，导致现在 $RTT_S$ 就无法变大。

于是又进行了改进：
报文段每重传一次，就把超时重传 RTO 增大一些。典型的做法是取新的 RTO 为旧的 RTO 的两倍。当不在发生报文段的重传时，才根据上面 $(1.1)$ 式计算 RTO。
实践证明，这种策略较为合理。

总结， Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。

#### 冗余确认

每次都得等到报文段超过了 RTO 之后，才重传。
可以使用冗余确认，使得发送方在报文段超过 RTO 之前就知道要重传。

即每次收到报文段，就发送前面已接收的连续报文段的最后一个报文段的 ACK。

例子：
发送方发送报文段 1，2，3，4，5，
接收方收到 1，发送 1 的 ACK；
接收方收到 2，发送 2 的 ACK；
接收方收到 4，发送 2 的 ACK；
接收方收到 5，发送 2 的 ACK；

可以看到接收方每次收到报文段，就会发送前面已接收的连续报文段的最后一个报文段的 ACK。
发送方就知道应该要重传报文段 2，而不是等待报文段 2 超过了 RTO 后才重传。

2021.04.07